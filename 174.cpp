/* Раннє зв’язування

У більшості випадків, коли компілятор зустрічає виклик функції, 
він виконує раннє зв’язування, яке також називають статичною прив’язкою. 
Це означає, що ім’я функції або змінної вже відоме компілятору на етапі компіляції, 
і компілятор може безпосередньо замінити виклик функції на відповідну адресу в пам'яті.
#include <iostream>

void printValue(int value)
{
    std::cout << value;
}

int main()
{
    printValue(7); // це прямий виклик функції
    return 0;
}


Пізнє зв’язування

Іноді потрібно визначити, яку функцію викликати, 
не знаючи цього на етапі компіляції. 
Для цього використовується пізнє зв’язування (або динамічна прив’язка). 
У C++ пізнє зв’язування реалізується через вказівники на функції. 
Вказівник на функцію може бути змінений під час виконання програми, 
i на момент виклику програма не знає, яка саме функція буде викликана.

#include <iostream>

int add(int a, int b) { return a + b; }

int main()
{
    // Створюємо вказівник на функцію add
    int (*pFcn)(int, int) = add;
    std::cout << pFcn(4, 5) << std::endl; // виклик add(4 + 5)
    
    return 0;
}

*/
#include <iostream>

// Функції для математичних операцій
int add(int a, int b)
{
    return a + b;
}

int subtract(int a, int b)
{
    return a - b;
}

int multiply(int a, int b)
{
    return a * b;
}

int main()
{
    int a, b;
    std::cout << "Enter a number: ";
    std::cin >> a;

    std::cout << "Enter another number: ";
    std::cin >> b;

    int op;
    do
    {
        std::cout << "Enter an operation (0 = add, 1 = subtract, 2 = multiply): ";
        std::cin >> op;
    } while (op < 0 || op > 2);

    // Раннє зв'язування: викликаємо функцію напряму
    int result = 0;
    switch (op)
    {
        case 0: result = add(a, b); break;// Раннє зв'язування
        case 1: result = subtract(a, b); break;
        case 2: result = multiply(a, b); break;
    }

    std::cout << "The answer is: " << result << std::endl;

    // Пізнє зв'язування: використання вказівника на функцію
    int (*pFcn)(int, int) = nullptr;

    // Вказуємо на функцію в залежності від введеної операції
    switch (op)
    {
        case 0: pFcn = add; break;// Пізнє зв'язування
        case 1: pFcn = subtract; break;
        case 2: pFcn = multiply; break;
    }

    // Викликаємо функцію через вказівник pFcn
    std::cout << "The answer using function pointer is: " << pFcn(a, b) << std::endl;

    return 0;
}


/* Раннє зв’язування:
Визначається на етапі компіляції.
Швидше, оскільки немає проміжних кроків під час виконання.
Менше гнучкості, оскільки функція повинна бути відома на етапі компіляції.
Пізнє зв’язування:
Виконується на етапі виконання програми.
Повільніше, оскільки виклик функції через вказівник вимагає додаткових кроків.
Більша гнучкість, оскільки можна визначати, яку функцію викликати, тільки під час виконання програми. */